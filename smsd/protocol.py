#! /usr/bin/env python3

"""Протокол обмена данными с SMSD-LAN."""

from ctypes import LittleEndianStructure, Structure, c_ubyte, c_uint, c_ushort
from enum import Enum


class CMD_TYPE(Enum):
    """Команда, передаваемая по сети."""

    CODE_CMD_REQUEST = 0x00             # команда авторизации (поле DATA пакета содержит информацию для авторизации)
    CODE_CMD_RESPONSE = 0x01            # команда подтверждения (поле DATA пакета зависит от отправленной контроллеру команды)
    CODE_CMD_POWERSTEP01 = 0x02         # команда управления в реальном масштабе времени (поле DATA пакета содержит команды POWERSTEP01 типа SMSD_CMD_Type)
    CODE_CMD_POWERSTEP01_W_MEM0 = 0x03  # команда записи программы управления в банк памяти 0
    CODE_CMD_POWERSTEP01_W_MEM1 = 0x04  # команда записи программы управления в банк памяти 1
    CODE_CMD_POWERSTEP01_W_MEM2 = 0x05  # команда записи программы управления в банк памяти 2
    CODE_CMD_POWERSTEP01_W_MEM3 = 0x06  # команда записи программы управления в банк памяти 3
    CODE_CMD_POWERSTEP01_R_MEM0 = 0x07  # команда чтения программы управления из банка памяти 0
    CODE_CMD_POWERSTEP01_R_MEM1 = 0x08  # команда чтения программы управления из банка памяти 1
    CODE_CMD_POWERSTEP01_R_MEM2 = 0x09  # команда чтения программы управления из банка памяти 2
    CODE_CMD_POWERSTEP01_R_MEM3 = 0x0A  # команда чтения программы управления из банка памяти 3
    CODE_CMD_CONFIG_SET = 0x0B          # команда записи настроек LAN
    CODE_CMD_CONFIG_GET = 0x0C          # команда чтения настроек LAN
    CODE_CMD_PASSWORD_SET = 0x0D        # команда изменения пароля для авторизации
    CODE_CMD_ERROR_GET = 0x0E           # команда чтения количества включений рабочего режима Контроллера и статистики по ошибкам


class ERROR_OR_COMMAND(Enum):
    """Список возможных вариантов значений поля ERROR_OR_COMMAND."""

    OK = 0x00                           # без ошибок
    OK_ACCESS = 0x01                    # признак получения доступа к управлению Контроллером
    ERROR_ACCESS = 0x02                 # признак ошибки получения доступа к управлению Контроллером
    ERROR_ACCESS_TIMEOUT = 0x03         # признак того, что не истёк таймаут для повторной авторизации (1 сек)
    ERROR_XOR = 0x04                    # ошибка контрольной суммы команды
    ERROR_NO_COMMAND = 0x05             # признак того, что такой команды не существует
    ERROR_LEN = 0x06                    # ошибочная длина пакета
    ERROR_RANGE = 0x07                  # выход за допустимый диапазон значений
    ERROR_WRITE = 0x08                  # ошибка записи
    ERROR_READ = 0x09                   # ошибка чтения
    ERROR_PROGRAMS = 0x0A               # для внутреннего пользования
    ERROR_WRITE_SETUP = 0x0B            # для внутреннего пользования
    NO_NEXT = 0x0C                      # для внутреннего пользования
    END_PROGRAMS = 0x0D                 # конец программы
    COMMAND_GET_STATUS_IN_EVENT = 0x0E  # в поле данных RETURN_DATA содержится битовая карта входных сигналов
    COMMAND_GET_MODE = 0x0F             # в поле данных RETURN_DATA содержится битовая карта текущих настроек Контроллера
    COMMAND_GET_ABS_POS = 0x10          # в поле данных RETURN_DATA содержится текущее положение шагового двигателя в шагах
    COMMAND_GET_EL_POS = 0x11           # в поле данных RETURN_DATA содержится текущее электрическое положение двигателя
    COMMAND_GET_SPEED = 0x12            # в поле данных RETURN_DATA содержится текущая скорость двигателя
    COMMAND_GET_MIN_SPEED = 0x13        # в поле данных RETURN_DATA содержится текущая установленная минимальная скорость двигателя
    COMMAND_GET_MAX_SPEED = 0x14        # в поле данных RETURN_DATA содержится текущая установленная максимальная скорость двигателя
    COMMAND_GET_STACK = 0x15            # в поле данных RETURN_DATA содержится информация о номере текущей выполняемой программы и номер выполняемой команды
    STATUS_RELE_SET = 0x16              # реле включено
    STATUS_RELE_CLR = 0x17              # реле выключено


class COMMAND(Enum):
    """Список кодов исполнительных команд."""

    CMD_POWERSTEP01_END = 0x00                      # обозначение конца программы
    CMD_POWERSTEP01_GET_SPEED = 0x01                # чтение текущего значения скорости
    CMD_POWERSTEP01_STATUS_IN_EVENT = 0x02          # чтение текущего состояния входных сигналов
    CMD_POWERSTEP01_SET_MODE = 0x03                 # установка параметров управления двигателем
    CMD_POWERSTEP01_GET_MODE = 0x04                 # чтение настроек управления двигателем
    CMD_POWERSTEP01_SET_MIN_SPEED = 0x05            # установка минимальной скорости вращения двигателя
    CMD_POWERSTEP01_SET_MAX_SPEED = 0x06            # установка максимальной скорости шагового двигателя
    CMD_POWERSTEP01_SET_ACC = 0x07                  # установка значения ускорения двигателя
    CMD_POWERSTEP01_SET_DEC = 0x08                  # установка значения замедления шагового двигателя
    CMD_POWERSTEP01_SET_FS_SPEED = 0x09             # установка скорости перехода на полношаговый режим работы
    CMD_POWERSTEP01_SET_MASK_EVENT = 0x0A           # маскирование входных сигналов
    CMD_POWERSTEP01_GET_ABS_POS = 0x0B              # чтение положения двигателя
    CMD_POWERSTEP01_GET_EL_POS = 0x0C               # чтение электрического положения ротора двигателя
    CMD_POWERSTEP01_GET_STATUS_AND_CLR = 0x0D       # чтение текущего статуса контроллера и сброса всех флагов ошибок
    CMD_POWERSTEP01_RUN_F = 0x0E                    # старт непрерывного вращения двигателя в прямом направлении на указанной скорости
    CMD_POWERSTEP01_RUN_R = 0x0F                    # старт непрерывного вращения двигателя в обратном направлении на указанной скорости
    CMD_POWERSTEP01_MOVE_F = 0x10                   # перемещение двигателя в прямом направлении на указанную величину
    CMD_POWERSTEP01_MOVE_R = 0x11                   # перемещение двигателя в обратном направлении на указанную величину
    CMD_POWERSTEP01_GO_TO_F = 0x12                  # перемещение в заданную позицию в прямом направлении
    CMD_POWERSTEP01_GO_TO_R = 0x13                  # перемещение в заданную позицию в обратном направлении
    CMD_POWERSTEP01_GO_UNTIL_F = 0x14               # старт вращения двигателя в прямом направлении на максимальной скорости до получения сигнала на вход
    CMD_POWERSTEP01_GO_UNTIL_R = 0x15               # старт вращения двигателя в обратном направлении на максимальной скорости до получения сигнала на вход
    CMD_POWERSTEP01_SCAN_ZERO_F = 0x16              # поиск нулевого положения в прямом направлении с заданной скоростью
    CMD_POWERSTEP01_SCAN_ZERO_R = 0x17              # поиск нулевого положения в обратном направлении с заданной скоростью
    CMD_POWERSTEP01_SCAN_LABEL_F = 0x18             # поиск метки положения в прямом направлении
    CMD_POWERSTEP01_SCAN_LABEL_R = 0x19             # поиск метки положения в обратном направлении
    CMD_POWERSTEP01_GO_ZERO = 0x1A                  # перемещение в нулевое положение
    CMD_POWERSTEP01_GO_LABEL = 0x1B                 # перемещение в положение, которое было отмечено как метка
    CMD_POWERSTEP01_GO_TO = 0x1C                    # перемещение в заданное положение по кратчайшему пути
    CMD_POWERSTEP01_RESET_POS = 0x1D                # обнуление счетчика текущего положения
    CMD_POWERSTEP01_RESET_POWERSTEP01 = 0x1E        # полный аппаратный и программный сброс модуля управления шаговым двигателем, но не контроллера в целом
    CMD_POWERSTEP01_SOFT_STOP = 0x1F                # плавная остановка двигателя с заданным ускорением
    CMD_POWERSTEP01_HARD_STOP = 0x20                # резкая остановка шагового двигателя
    CMD_POWERSTEP01_SOFT_HI_Z = 0x21                # плавная остановка шагового двигателя с заданным ускорением
    CMD_POWERSTEP01_HARD_HI_Z = 0x22                # резкая остановка и обесточивания обмоток двигателя
    CMD_POWERSTEP01_SET_WAIT = 0x23                 # задание паузы
    CMD_POWERSTEP01_SET_RELE = 0x24                 # включение реле контроллера
    CMD_POWERSTEP01_CLR_RELE = 0x25                 # выключение реле контроллера
    CMD_POWERSTEP01_GET_RELE = 0x26                 # запрос состояния реле контроллера
    CMD_POWERSTEP01_WAIT_IN0 = 0x27                 # ожидание поступления сигнала на вход IN0
    CMD_POWERSTEP01_WAIT_IN1 = 0x28                 # ожидание поступления сигнала на вход IN1
    CMD_POWERSTEP01_GOTO_PROGRAM = 0x29             # безусловный переход к заданной команде заданной программы
    CMD_POWERSTEP01_GOTO_PROGRAM_IF_IN0 = 0x2A      # переход к заданной команде заданной программы, если на входе IN0 присутствует сигнал
    CMD_POWERSTEP01_GOTO_PROGRAM_IF_IN1 = 0x2B      # переход к заданной команде заданной программы, если на входе IN1 присутствует сигнал
    CMD_POWERSTEP01_LOOP_PROGRAM = 0x2C             # создание циклов – контроллер повторяет в цикле заданное число раз заданное количество команд
    CMD_POWERSTEP01_CALL_PROGRAM = 0x2D             # вызов подпрограммы
    CMD_POWERSTEP01_RETURN_PROGRAM = 0x2E           # возврат из подпрограммы в основную программу
    CMD_POWERSTEP01_START_PROGRAM_MEM0 = 0x2F       # старт программы, записанной в область памяти 0 контроллера
    CMD_POWERSTEP01_START_PROGRAM_MEM1 = 0x30       # старт программы, записанной в область памяти 1 контроллера
    CMD_POWERSTEP01_START_PROGRAM_MEM2 = 0x31       # старт программы, записанной в область памяти 2 контроллера
    CMD_POWERSTEP01_START_PROGRAM_MEM3 = 0x32       # старт программы, записанной в область памяти 3 контроллера
    CMD_POWERSTEP01_STOP_PROGRAM_MEM = 0x33         # остановка выполнения программы
    CMD_POWERSTEP01_STEP_CLOCK = 0x34               # изменение режима управления двигателем на импульсное сигналами EN, STEP, DIR
    CMD_POWERSTEP01_STOP_USB = 0x35                 # остановка работы микросхемы USB
    CMD_POWERSTEP01_GET_MIN_SPEED = 0x36            # чтение текущего значения установленной минимальной скорости
    CMD_POWERSTEP01_GET_MAX_SPEED = 0x37            # чтение текущего значения установленной максимальной скорости
    CMD_POWERSTEP01_GET_STACK = 0x38                # чтение информации о выполняемой в данный момент программе
    CMD_POWERSTEP01_GOTO_PROGRAM_IF_ZERO = 0x39     # переход к заданной команде заданной программы, если значение текущей позиции равно 0
    CMD_POWERSTEP01_GOTO_PROGRAM_IF_IN_ZERO = 0x3A  # переход к заданной команде заданной программы, в случае, если на входе SET_ZERO присутствует сигнал
    CMD_POWERSTEP01_WAIT_CONTINUE = 0x3B            # ожидание прихода синхросигнала на вход CONTINUE
    CMD_POWERSTEP01_SET_WAIT_2 = 0x3C               # задание паузы (может быть прервано поступлением сигнала на вход IN0, IN1 или SET_ZERO)
    CMD_POWERSTEP01_SCAN_MARK2_F = 0x3D             # поиск метки положения в прямом направлении
    CMD_POWERSTEP01_SCAN_MARK2_R = 0x3E             # поиск метки положения в обратном направлении


class LAN_COMMAND_TYPE(Structure):
    """Структура информационного пакета передачи данных."""

    _pack_ = 1
    _fields_ = [
        ("XOR", c_ubyte),           # контрольная сумма
        ("VER", c_ubyte),           # версия протокола
        ("TYPE", c_ubyte),          # тип команды, передаваемой по сети
        ("ID", c_ubyte),            # уникальный идентификатор, предназначеный для однозначной идентификации ответа на отправленную команду
        ("LENGTH", c_ushort),       # длина информационной части пакета
        ("DATA", c_ubyte * 1024),   # информационная часть пакета
    ]


class LAN_ERROR_STATISTICS(Structure):
    """Структура счётчиков событий."""

    _pack_ = 1
    _fields_ = [
        ("N_STARTS", c_uint),                   # количество раз, когда были запитаны обмотки шагового двигателя
        ("ERROR_XT", c_uint),                   # количество внутренних ошибок запуска тактового генератора
        ("ERROR_TIME_OUT", c_uint),             # количество ошибок превышения времени выполнения основного цикла программы
        ("ERROR_INIT_POWERSTEP01", c_uint),     # количество ошибок инициализации чипа PowerSTEP01
        ("ERROR_INIT_WIZNET", c_uint),          # количество ошибок инициализации чипа W5500
        ("ERROR_INIT_FRAM", c_uint),            # количество ошибок инициализации чипа памяти FRAM
        ("ERROR_SOCKET", c_uint),               # количество ошибок соединений по Ethernet
        ("ERROR_FRAM", c_uint),                 # количество ошибок обмена с чипом памяти FRAM
        ("ERROR_INTERRUPT", c_uint),            # количество ошибок обработки прерывания
        ("ERROR_EXTERN_5V", c_uint),            # количество перегрузок по току, внутреннего выходного источника питания в 5В
        ("ERROR_EXTERN_VDD", c_uint),           # количество выходов за диапазон питающего напряжения Контроллера
        ("ERROR_THERMAL_POWERSTEP01", c_uint),  # количество перегревов чипа PowerSTEP01
        ("ERROR_THERMAL_BRAKE", c_uint),        # количество перегревов тормозного резистора
        ("ERROR_COMMAND_POWERSTEP01", c_uint),  # количество ошибок при передаче управляющих команд в чип PowerSTEP01
        ("ERROR_UVLO_POWERSTEP01", c_uint),     # количество ошибок
        ("ERROR_STALL_POWERSTEP01", c_uint),    # количество ошибок
        ("ERROR_WORK_PROGRAM", c_uint),         # количество ошибок выполнения программы управления
    ]


class POWERSTEP_STATUS_TYPEDEF(LittleEndianStructure):
    """Статус состояния процесса управления шаговым двигателем."""

    _fields_ = [
        ("HIZ", c_ushort, 1),           # Z-состояние обмоток, если 1- обмотки шагового двигателя обесточены, 0 – обмотки шагового двигателя запитаны
        ("BUSY", c_ushort, 1),          # ожидание, если 1- блок готов к выполнению следующей команды, 0 – выполняется предыдущая команда
        ("SW_F", c_ushort, 1),          # если 1- функция SW включена, 0 – функция SW выключена
        ("SW_EVN", c_ushort, 1),        # флаг события SW если 1- событие наступило, 0 – событие не наступило
        ("DIR", c_ushort, 1),           # направление вращения, если 1- основное направление, 0 – обратное направление
        ("MOT_STATUS", c_ushort, 2),    # статус текущего действия, если 0 – двигатель остановлен, 1 – ускорение, 2 - торможение, 3 - равномерное вращение шагового двигателя
        ("CMD_ERROR", c_ushort, 1),     # ошибка выполнения команды, если 1- ошибка выполнения команды, 0 – без ошибок
        ("RESERVE", c_ushort, 8),       # зарезервированно
    ]


class COMMANDS_RETURN_DATA_TYPE(Structure):
    """Ответ на команды CODE_CMD_RESPONSE или CODE_CMD_POWERSTEP01."""

    _anonymous_ = ("STATUS_POWERSTEP01",)
    _pack_ = 1
    _fields_ = [
        ("STATUS_POWERSTEP01", POWERSTEP_STATUS_TYPEDEF),   # флаги, отвечающие за текущее состояние схемы управление шаговым двигателем
        ("ERROR_OR_COMMAND", c_ubyte),                      # код статуса выполнения команды или код ошибки
        ("RETURN_DATA", c_uint),                            # поле данных
    ]


class SMSD_CMD_TYPE(LittleEndianStructure):
    """Структура исполнительных команды управления."""

    _fields_ = [
        ("RESERVE", c_uint, 3),     # не используется
        ("ACTION", c_uint, 1),      # 0 – для внутреннего использования
        ("COMMAND", c_uint, 6),     # код исполнительной команды
        ("DATA", c_uint, 22),       # параметр команды
    ]


class SMSD_LAN_CONFIG_TYPE(Structure):
    """Структура сетевых настроек контроллера."""

    _pack_ = 1
    _fields_ = [
        ("MAC", c_ubyte * 6),       # MAC адрес лазера
        ("IP", c_ubyte * 4),        # IP адрес лазера
        ("SN", c_ubyte * 4),        # адрес подсети лазера
        ("GW", c_ubyte * 4),        # адрес шлюза лазера
        ("DNS", c_ubyte * 4),       # адрес DNS лазера
        ("PORT", c_ushort),         # номер порта
        ("DHCP", c_ubyte),          # включен DHCP или нет
    ]
